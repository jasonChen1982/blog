---
title: 现代浏览器渲染流水线
date: 2015-07-10
status: doing
---

浏览器的渲染流水线是一个即有趣又比较复杂的渲染流程，有趣是因为它的每一步都是那么的符合图形渲染的规则，而复杂是因为整个渲染过程是一个融合了各种综合的技术在里面是一个比较复杂的技术系统。为了讲清楚现代浏览器的渲染流水线，我们先从一些简单的开始。

### 从输入URL开始

当用户输入一个可用的URL的时候，浏览器就会调用其资源加载器去加载URL对应的网页，主要的过程如下：

1. 加载完HTML主文档之后，浏览器调用HTML解析器来解析HTML文档变成一系列的词语`token`。
2. 在这过程中解析器会根据词语`token`来构建节点形成`DOM`树。
3. 假如在构建`DOM`的过程中遇到的是`js`代码，则调用`js`引擎解析并执行。同时停止`DOM`树的创建，这主要是因为`js`的执行会修改`DOM`树，为了避免两个操作的结果产生不可控的冲突，并且简化流程所以干脆停掉`DOM`树的创建。
4. 如果节点引入了其它资源，如`图片`、`css`、`视频`等，浏览器则调用资源加载器进行异步的加载他们。但是如果是没有背标记为异步的`js`资源时，则需要停止`DOM`树的创建，直到`js`加载并被`js`引擎执行完后才继续创建。

> 在网页加载过程中会出发`DOMContentLoaded`事件和`onload`事件，`DOMContentLoaded`事件是在`DOM`树创建完毕后立即出发，`onload`事件是在页面所依赖的资源被加载完之后触发。

创建`DOM`树只是浏览器渲染页面的第一步，在创建完了`DOM`树和接收完`css`样式之后就会利用`css`和`DOM`树创建出`RenderObject`树。创建`RenderObject`树的具体步骤如下：

1. 将`css`解析成内部对象，并匹配作用到`DOM`树上相应的`DOM`节点，这样就形成了`RenderObject`树。
2. `RenderObject`树在创建的同时，浏览器会根据页面的层次结构创建`RenderLayer`树。同时为`RenderLayer`创建虚拟的绘图上下文。

本来到这里浏览器就可以调用光栅化器来开始绘制图像了，但是这样做并不优化。按照这种方式的话，页面只绘制一次还好，要是页面里面某个位置有一个带有动画的元素的话，浏览器就得一遍一遍的重新光栅化整个页面（聪明的浏览器会只绘制脏区域，但是也会涉及到一系列牵连元素计算同样耗时）。

> 光栅化的过程可以理解成是将元素从几何数据、纹理数据、矩阵姿态等这些综合描述的形式经过计算扫描生成像素描述形式的过程。



### Chromium多进程模型

Chromium采用的是多进程架构，主要有`Browser进程`、可以有多个的`Renderer进程`、`GPU进程`、`NAPI插件进程`、`Pepper插件进程`等，各个进程的介绍如下：

* Browser进程：是浏览器的主进程，负责整个应用各个部件的调度和管理，是其它类型进程的祖先，其它类型的进程都由它来创建和销毁。该进程在整个浏览器中只有一个。
* Renderer进程：是网页的渲染进程，`Blink`和`Webkit`的渲染工作主要在这个进程。在浏览器中会有多个，一般每个页面tag中会有一个来负责该tag页面的渲染，但是要注意的是这个规则是可以被改变的。
* GPU进程：只存在一个，并且只有在`GPU硬件加速`开启的时候才会被创建。
* NAPI插件进程：只会为同一类插件创建一个进程，多个页面上使用的同个插件是共享同一个进程的。
* Pepper插件进程： 和NAPI类似



renderObject

## 现代浏览器的渲染

现代浏览器一般都采用合成化渲染的机制来渲染高复杂度和高性能的现代网页，至于为什么要采用合成化渲染而不是其他的方式这就要讲到其他的两种渲染机制了，一种是软件渲染机制，另一种就是硬件加速渲染机制。 
像以前的老IE时代的网页基本上都是通过CPU进行绘制的也就是采用软件渲染的机制来绘制整个页面，
要解释清楚这三种渲染机制的特性就得再介绍一个知识点，那就是光栅化。 
所谓的光栅化就是将基于数学几何数据的描述转化为基于像素点的描述。CPU和GPU都能做光栅化。
CPU做光栅化的优势是可以很方便的处理非常复杂的几何描述，例如文字的几何描述、svg-path等等这种强逻辑的路径描述等。当然缺点也很明显，例如参杂了复杂的逻辑和不可并行的特点，CPU光栅化速度会比较慢。
GPU的光栅化的优势是，GPU可以极高并发的
其实，当我们的页面从服务器请求回来时还是一些基于文本的描述，当浏览器得到html描述和css样式描述之后，浏览器就会开始解析这些描述然后变成一块一块的几何数据表述（例如描述一块内容的边框坐标点，边框的填充颜色等等基于几何数据的描述信、息。可以想象成svg的那种描述方式）。数学几何数据光栅化之后就是一张基于像素点位图了（bitmap:基于像素的描述，可以想象成jpg、png这种类型的图片）。然而目前的这一个过程还是通过CPU实现的（当然，chromuim正计划将这里适合GPU实现的步骤移交到GPU内进行处理，并且有了实质进展 感兴趣的请参考：Slimming Paint），之所以采用CPU实现这一过程的主要原因是类似于text、svg-path这种东西的路径描述比较复杂，有些时候还会有很强的逻辑在里面，比如在绘制svg-path时可能会出现某一点的位置可能会受到前N个点的影响，这种强逻辑在GPU上是不适合的，GPU擅长处理的是单纯无逻辑的点、线、三角形数据。

由于文档流的关系，后面DOM的层级默认情况下高于前面的，所以如果出现overlap的layer可以通过查看前面节点的层级来定位问题。
