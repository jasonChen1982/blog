---
title: 现代浏览器渲染流水线
date: 2015-07-10
status: doing
---

浏览器的渲染流水线是一个即有趣又比较复杂的渲染流程，有趣是因为它的每一步都是那么的符合图形渲染的规则，而复杂是因为整个渲染过程是一个融合了各种综合的技术在里面是一个比较复杂的技术系统。为了讲清楚现代浏览器的渲染流水线，我们先从一些简单的开始。

### 从输入URL开始

当用户输入一个可用的URL的时候，浏览器就会调用其资源加载器去加载URL对应的网页，主要的过程如下：

1. 加载完HTML主文档之后，浏览器调用HTML解析器来解析HTML文档变成一系列的词语`token`。
2. 在这过程中解析器会根据词语`token`来构建节点形成`DOM`树。
3. 假如在构建`DOM`的过程中遇到的是`js`代码，则调用`js`引擎解析并执行。同时停止`DOM`树的创建，这主要是因为`js`的执行会修改`DOM`树，为了避免两个操作的结果产生不可控的冲突，并且简化流程所以干脆停掉`DOM`树的创建。
4. 如果节点引入了其它资源，如`图片`、`css`、`视频`等，浏览器则调用资源加载器进行异步的加载他们。但是如果是没有背标记为异步的`js`资源时，则需要停止`DOM`树的创建，直到`js`加载并被`js`引擎执行完后才继续创建。

> 在网页加载过程中会出发`DOMContentLoaded`事件和`onload`事件，`DOMContentLoaded`事件是在`DOM`树创建完毕后立即出发，`onload`事件是在页面所依赖的资源被加载完之后触发。

创建`DOM`树只是浏览器渲染页面的第一步，在创建完了`DOM`树和接收完`css`样式之后就会利用`css`和`DOM`树创建出`RenderObject`树。创建`RenderObject`树的具体步骤如下：

1. 将`css`解析成内部对象，并匹配作用到`DOM`树上相应的`DOM`节点，同时去掉一些不可见的`DOM`后就形成了`RenderObject`树。
2. `RenderObject`树为了布局计算和后续渲染所构建的一个内部树形结构，每个`RenderObject`节点保存供浏览器绘制`DOM`的各种信息。
3. `document`节点、可视化节点、渲染需要的`RenderBlock`节点都会创建`RenderObject`
4. `RenderObject`树在创建的同时，浏览器会根据页面的层次结构创建`RenderLayer`树。同时为`RenderLayer`创建虚拟的绘图上下文。

> `RenderBlock`是用来表示块元素的，但是在某种情况下`webkit`需要创建匿名的`RenderBlock`对象。`RenderBlock`对象的子女必须是同种类型的元素（内联、块）当`RenderBlock`里面包含两张类型的元素时，浏览器就是创建匿名的`RenderBlock`对象来包裹那些内联的元素。

`RenderObject`常见的实例对象：

1. `RenderView`: 一般是为document创建的
2. `RenderBlock`: 一般是为块级内容创建的
3. `RenderInline`: 一般是为内联内容创建的
4. `RenderSVGModel`: 一般是为svg内容创建的

在创建完`RenderObject`树之后，并没有到达渲染的地步。因为网页里面的某些可能有层叠关系，并且还有变透明效果，甚至还有现代web样式的滤镜效果，颜色叠加等特殊效果。目前的结果并不能很好的视线这些，所以浏览器在创建完`RenderObject`树之后为某些具有特殊属性的`RenderObject`创建`RenderLayer`对象。一般来说，某个`RenderObject`节点的后代都属于该节点，除非`webkit`为某些后代`RenderObject`节点创建了一个新的`RenderLayer`对象。那么具备哪些特性的`RenderObject`会被提升为`RenderLayer`对象呢？具体有以下几个规则：

1. `document`节点对应的`RenderView`节点（`RenderView`类是`RenderObject`类的实例）
2. `HTML`节点对应的`RenderBlock`节点。
3. 明确的给定了`CSS position`，这里的`position`包括`position:absolute`、 `position:relative`、 `transform`。
4. 有透明度效果的`RenderObject`节点
5. 有`overflow`、 `alhpa遮罩`、 `css 反射`等效果的`RenderObject`节点
6. `canvas 2d|3d`的`RenderObject`节点
7. `video`节点对应的`RenderObject`节点

到这个时候，页面的渲染准备已经基本完成。早在`RenderObject`树中每个`RenderObject`节点内部都已经保存了该节点内的所有内容的绘制命令和数据。本来到这里浏览器就可以调用光栅化器来开始绘制图像了，但是这样做并不优化。因为我们的网页不可能只绘制一次，网页绘制完之后可能还会有非常多的更新绘制，所以我们需要设计出一个方式来减小绘制的成本。

> 光栅化的过程可以理解成是将元素从几何数据、纹理数据、矩阵姿态等这些综合描述的形式经过计算扫描生成像素描述形式的过程。

在讲渲染之前，我们先来介绍几种比较常用的渲染方式。

### 渲染方式

我们知道，渲染一般可以采用两种方式，一种是基于`CPU`的`软件渲染`方式，还有一个就是基于`GPU`的`硬件渲染`方式。当然还有一种鉴于这两种方式之间的一种方式`软件渲染的合成化`。

其实`webkit`内核的浏览器就是采用这种混合的方式，一部分复杂逻辑绘制的层交由`CPU`来进行软件渲染（例如大量的`文本类型`的层、复杂的`svg路径`的层），几何特征明显的层交由`GPU`来进行硬件渲染。这样处理的原因是由于`文本类型`和`svg路径`在渲染之前都是由一些复杂路径来描述的几何图形，并且其中还有大量的点的位置是由上一个甚至上N个点的位置来确定的，这种携带者逻辑的描述方式并不适合`GPU`的渲染流水线，在这种情况下反倒使用`CPU`来渲染更加合适，`GPU`只适合渲染那些几何数据点很简单、很明确的几何图形。

上面介绍了目前大部分浏览器采用的渲染方案是一种`软件绘图加合成化渲染`的方式，那到底什么是`软件绘图加合成化渲染`呢？其实`软件绘图加合成化渲染`就是将渲染任务



### Chromium多进程模型

Chromium采用的是多进程架构，主要有`Browser进程`、可以有多个的`Renderer进程`、`GPU进程`、`NAPI插件进程`、`Pepper插件进程`等，各个进程的介绍如下：

* Browser进程：是浏览器的主进程，负责整个应用各个部件的调度和管理，是其它类型进程的祖先，其它类型的进程都由它来创建和销毁。该进程在整个浏览器中只有一个。
* Renderer进程：是网页的渲染进程，`Blink`和`Webkit`的渲染工作主要在这个进程。在浏览器中会有多个，一般每个页面tag中会有一个来负责该tag页面的渲染，但是要注意的是这个规则是可以被改变的。
* GPU进程：只存在一个，并且只有在`GPU硬件加速`开启的时候才会被创建。
* NAPI插件进程：只会为同一类插件创建一个进程，多个页面上使用的同个插件是共享同一个进程的。
* Pepper插件进程： 和NAPI类似


> 但是在Android平台上，GPU进程演化成Renderer进程的一个线程，这主要是为了节省资源。
> 并且Renderer进程在Android上也会演变成一个安卓系统的`服务service`进程，同时由于受安卓系统的限制Renderer进程的数量会被严格限制，主要表现就是处于后台的页面都只是一个影子快照，这个时候浏览器将会移除这种页面的渲染设施，只有当用户切换回来的时候才会重新加载和渲染。


renderObject

## 现代浏览器的渲染

现代浏览器一般都采用合成化渲染的机制来渲染高复杂度和高性能的现代网页，至于为什么要采用合成化渲染而不是其他的方式这就要讲到其他的两种渲染机制了，一种是软件渲染机制，另一种就是硬件加速渲染机制。 
像以前的老IE时代的网页基本上都是通过CPU进行绘制的也就是采用软件渲染的机制来绘制整个页面，
要解释清楚这三种渲染机制的特性就得再介绍一个知识点，那就是光栅化。 
所谓的光栅化就是将基于数学几何数据的描述转化为基于像素点的描述。CPU和GPU都能做光栅化。
CPU做光栅化的优势是可以很方便的处理非常复杂的几何描述，例如文字的几何描述、svg-path等等这种强逻辑的路径描述等。当然缺点也很明显，例如参杂了复杂的逻辑和不可并行的特点，CPU光栅化速度会比较慢。
GPU的光栅化的优势是，GPU可以极高并发的
其实，当我们的页面从服务器请求回来时还是一些基于文本的描述，当浏览器得到html描述和css样式描述之后，浏览器就会开始解析这些描述然后变成一块一块的几何数据表述（例如描述一块内容的边框坐标点，边框的填充颜色等等基于几何数据的描述信、息。可以想象成svg的那种描述方式）。数学几何数据光栅化之后就是一张基于像素点位图了（bitmap:基于像素的描述，可以想象成jpg、png这种类型的图片）。然而目前的这一个过程还是通过CPU实现的（当然，chromuim正计划将这里适合GPU实现的步骤移交到GPU内进行处理，并且有了实质进展 感兴趣的请参考：Slimming Paint），之所以采用CPU实现这一过程的主要原因是类似于text、svg-path这种东西的路径描述比较复杂，有些时候还会有很强的逻辑在里面，比如在绘制svg-path时可能会出现某一点的位置可能会受到前N个点的影响，这种强逻辑在GPU上是不适合的，GPU擅长处理的是单纯无逻辑的点、线、三角形数据。

由于文档流的关系，后面DOM的层级默认情况下高于前面的，所以如果出现overlap的layer可以通过查看前面节点的层级来定位问题。
