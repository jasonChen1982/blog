---
title: 现代浏览器渲染流水线
date: 2015-07-10
status: finished
---

浏览器的渲染流水线是一个即有趣又比较复杂的渲染流程，有趣是因为它的每一步都是那么的符合图形渲染的规则，而复杂是因为整个渲染过程是一个融合了各种综合的技术在里面，是一个比较复杂的技术系统。为了讲清楚现代浏览器的渲染流水线，我们先从最简单的开始。

### 从输入URL开始

当用户输入一个可用的URL的时候，浏览器就会调用其资源加载器去加载URL对应的网页，主要的过程如下：

1. 加载完HTML主文档之后，浏览器调用HTML解析器来解析HTML文档变成一系列的词语`token`。
2. 在这过程中解析器会根据词语`token`来构建节点形成`DOM`树。
3. 假如在构建`DOM`的过程中遇到的是`js`代码，则调用`js`引擎解析并执行。同时停止`DOM`树的创建，这主要是因为`js`的执行会修改`DOM`树，为了避免两个操作的结果产生不可控的冲突，并且简化流程所以干脆停掉`DOM`树的创建。
4. 如果节点引入了其它资源，如`图片`、`css`、`视频`等，浏览器则调用资源加载器进行异步的加载他们。但是如果是没有背标记为异步的`js`资源时，则需要停止`DOM`树的创建，直到`js`加载并被`js`引擎执行完后才继续创建。

> 在网页加载过程中会出发`DOMContentLoaded`事件和`onload`事件，`DOMContentLoaded`事件是在`DOM`树创建完毕后立即出发，`onload`事件是在页面所依赖的资源被加载完之后触发。

创建`DOM`树只是浏览器渲染页面的第一步，在创建完了`DOM`树和接收完`css`样式之后就会利用`css`和`DOM`树创建出`RenderObject`树。创建`RenderObject`树的具体步骤如下：

1. 将`css`解析成内部对象，并匹配作用到`DOM`树上相应的`DOM`节点，同时去掉一些不可见的`DOM`后就形成了`RenderObject`树。
2. `RenderObject`树为了布局计算和后续渲染所构建的一个内部树形结构，每个`RenderObject`节点保存供浏览器绘制`DOM`的各种信息。
3. `document`节点、可视化节点、渲染需要的`RenderBlock`节点都会创建`RenderObject`
4. `RenderObject`树在创建的同时，浏览器会根据页面的层次结构创建`RenderLayer`树。同时为`RenderLayer`创建虚拟的绘图上下文。

> `RenderBlock`是用来表示块元素的，但是在某种情况下`webkit`需要创建匿名的`RenderBlock`对象。`RenderBlock`对象的子女必须是同种类型的元素（内联、块）当`RenderBlock`里面包含两张类型的元素时，浏览器就是创建匿名的`RenderBlock`对象来包裹那些内联的元素。

`RenderObject`常见的实例对象：

1. `RenderView`: 一般是为document创建的
2. `RenderBlock`: 一般是为块级内容创建的
3. `RenderInline`: 一般是为内联内容创建的
4. `RenderSVGModel`: 一般是为svg内容创建的

在创建完`RenderObject`树之后，并没有到达渲染的地步。因为网页里面的某些元素可能有层叠关系，并且还有半透明效果，甚至还有现代web样式的滤镜效果，颜色叠加等特殊效果。目前的结果并不能很好的视线这些，所以浏览器在创建完`RenderObject`树之后为某些具有特殊属性的`RenderObject`创建`RenderLayer`对象。一般来说，某个`RenderObject`节点的后代都属于该节点，除非`webkit`为某些后代`RenderObject`节点创建了一个新的`RenderLayer`对象。那么具备哪些特性的`RenderObject`会被提升为`RenderLayer`对象呢？具体有以下几个规则：

1. `document`节点对应的`RenderView`节点（`RenderView`类是`RenderObject`类的实例）
2. `HTML`节点对应的`RenderBlock`节点。
3. 明确的给定了`CSS position`，这里的`position`包括`position:absolute`、 `position:relative`、 `transform`。
4. 有透明度效果的`RenderObject`节点
5. 有`overflow`、 `alhpa遮罩`、 `css 反射`等效果的`RenderObject`节点
6. `canvas 2d|3d`的`RenderObject`节点
7. `video`节点对应的`RenderObject`节点

到这个时候，页面的渲染准备已经基本完成。早在`RenderObject`树中每个`RenderObject`节点内部都已经保存了该节点内的所有内容的绘制命令和数据。本来到这里浏览器就可以调用光栅化器来开始绘制图像了，但是这样做并不优化。因为我们的网页不可能只绘制一次，网页绘制完之后可能还会有非常多的更新绘制，所以我们需要设计出一个方式来减小绘制的成本。

在讲渲染之前，我们先来介绍几种比较常用的渲染方式。

### 渲染方式

我们知道，渲染一般可以采用两种方式，一种是基于`CPU`的`软件渲染`方式，还有一个就是基于`GPU`的`硬件渲染`方式。当然还有一种鉴于这两种方式之间的一种方式`软件渲染的合成化`。

其实`webkit`内核的浏览器就是采用这种混合的方式，普通的页面元素交由`CPU`来进行软件渲染（例如`dom+css`、`svg路径`等等），加速的`canvas`、`video`由`GPU`来进行硬件加速渲染，并且`GPU`还将负责合成那些被绘制出来的图层。这样处理的原因是由于当时条件限制并且`dom+css`、`svg路径`渲染之前都是一些由复杂路径来描述的几何图形，并且其中还有大量的点的位置是依赖上一个甚至上N个点的位置来确定的，这种携带者逻辑的描述方式并不适合`GPU`的渲染流水线，在这种情况下反倒使用`CPU`来渲染更加合适，`GPU`只适合渲染那些几何数据点很简单、很明确的几何图形。

> 早期的基于`webkit`内核的浏览器几乎都是采用这种渲染方式，但是现如今到了`chromium`时代，全面`GPU`渲染已经被实现，并且解决了之前说的复杂路径的问题。

`CPU`渲染的好处是可以只精确更新某一个脏矩形块，不需要重新渲染整个图层。但是`CPU`渲染的主要性能瓶颈是如何把绘制完的图像通过带宽比较小的数据总线上传到`GPU`内存（这一点在手机上的限制尤为明显），因为`CPU`绘制的内容一般都是存储在`CPU`所享有的内存上，这些图层要被合成化渲染就得上传到`GPU`享有的内存上。而`GPU`渲染的内容就不会有这个问题，而且`GPU`绘制确实要快很多。所以全面`GPU`光栅化渲染是一个必然的趋势。

> 光栅化的过程可以理解成是将元素从几何数据、纹理数据、矩阵姿态等这些综合描述的形式经过计算扫描生成像素描述形式的过程。光栅化可以由`CPU`和`GPU`来完成，具体要看各个移植的具体实现。

值得注意的是这里的合成需要提前做一些处理。因为如果每个`RenderLayer`对象都生成一个单独的图层的话是非常耗费内存资源的，这一点在移动设备上显得特别重要。所以需要有一个策略来收敛聚合一些`RenderLayer`对象。

### 合成层的作用

为了减少设备的内存资源，这时候合成层就该出场了。合成层的作用就是收敛聚合一些`RenderLayer`对象，形成一个具有后端存储空间的新层。这个层将在之后的合成器的合成操作中被使用，所以暂且叫它`合成层 ccLayer`，一个`ccLayer`可能会有多个后端存储。

在划分完`ccLayer`层之后，浏览器就会开始光栅化任务，将每个`ccLayer`包含的`RenderLayer`对象绘制到`ccLayer`的后端存储中保存起来。

> 这里的光栅化可以是`CPU`实现的光栅化，也可以是`GPU`实现的光栅化。在`webkit`的早期版本中普通元素的光栅化基本都是使用`CPU`来完成的，但是chromium一直致力于实现全面`GPU`实现的光栅化，并且目前已经解决了文字、复杂svg路径等内容的`GPU`光栅化，这里离不开`Skia`的升级。`GPU`光栅化将进一步提高网页的渲染性能。

在浏览器调度光栅化线程进行光栅化的同时，会调度合成器`compositor`将多个合成层`ccLayer`合成到一起，最终形成一张图显示在屏幕上。合成器在合成时会根据各个`ccLayer`的前后顺序、透明度、变换矩阵来正确的合并这些层。合成操作是一个非常快速的过程，它其实就是把渲染好了的图片进行再一次的光栅化，本质上可以理解成是一个纹理贴图的过程。细心的同学注意到了，在合成过程中使用到了透明度、变换矩阵，也正是因为透明度、变换矩阵是可以直接作用在合成器上的所以`transform`和`opacity`这些属性的动画是可以硬件加速的。

那么哪些`RenderLayer`对象可以变成合成层呢？一般情况下有以下这些：

1. 具有`css 3d`属性或者`css 透视`效果
2. 硬件加速的`video`标签
3. 硬件加速的`canvas`，这里包括被判断为可以硬件加速的`canvas 2d`和`webgl`
4. 当且仅当使用到了`transform`和`opacity`这些属性的动画，包括`transition`和`animation`
5. 硬件加速的`css filter`效果
6. 使用到了`clip`裁切、`reflection`并且后代中有一个合成层子节点。
7. 有一个比当前`RenderLayer`的z轴层级小的兄弟节点是合成层，这将出发`overlap`规则

除了上面列举的这些比较稳定的，还有一些在特定时期被内核特殊处理的`css`属性，例如早期会被创建合成层的`zoom`属性和前阵子增加的`position: fixed;`属性，都会触发合成层。具体的规则可以看这里[合成层规则](https://cs.chromium.org/chromium/src/third_party/WebKit/Source/platform/graphics/CompositingReasons.cpp)。

### 为什么要`GPU`光栅化

前面有讲到过，`cpu`光栅化的方式会有一个性能瓶颈，那就是`cpu`光栅化结果上传到`GPU`内存。虽然在一些`安卓`系统上提供了一种`CPU`和`GPU`共享的内存`Native Buffer`可以实现`Zero Copy`的`CPU`光栅化，但是这个东西的可用程度和本身容量通常都不足以满足使用。仍然摆脱不了传输拷贝速度慢的问题。

这样一来合成化机制不能改变（因为很多`CSS3`的效果以来这种机制），那就只有干脆直接把光栅化过程移动到`GPU`上来完成，这样才是一个合理的解决办法。

使用`GPU`光栅化首先要解决的一个问题就是对于那些`文本`、`svg路径`需要提前进行相应的`path`=>`trianglify`，将路径描述转化成三角形的描述，这一点对于了解`GPU`光栅化渲染的人来说非常容易了解。



显卡内存和系统内存

### Chromium多进程模型

Chromium采用的是多进程架构，主要有`Browser进程`、可以有多个的`Renderer进程`、`GPU进程`、`NAPI插件进程`、`Pepper插件进程`等，各个进程的介绍如下：

* Browser进程：是浏览器的主进程，负责整个应用各个部件的调度和管理，是其它类型进程的祖先，其它类型的进程都由它来创建和销毁。该进程在整个浏览器中只有一个。
* Renderer进程：是网页的渲染进程，`Blink`和`Webkit`的渲染工作主要在这个进程。在浏览器中会有多个，一般每个页面tag中会有一个来负责该tag页面的渲染，但是要注意的是这个规则是可以被改变的。
* GPU进程：只存在一个，并且只有在`GPU硬件加速`开启的时候才会被创建。
* NAPI插件进程：只会为同一类插件创建一个进程，多个页面上使用的同个插件是共享同一个进程的。
* Pepper插件进程： 和NAPI类似


> 但是在Android平台上，GPU进程演化成Renderer进程的一个线程，这主要是为了节省资源。
> 并且Renderer进程在Android上也会演变成一个安卓系统的`服务service`进程，同时由于受安卓系统的限制Renderer进程的数量会被严格限制，主要表现就是处于后台的页面都只是一个影子快照，这个时候浏览器将会移除这种页面的渲染设施，只有当用户切换回来的时候才会重新加载和渲染。


renderObject

## 现代浏览器的渲染

现代浏览器一般都采用合成化渲染的机制来渲染高复杂度和高性能的现代网页，至于为什么要采用合成化渲染而不是其他的方式这就要讲到其他的两种渲染机制了，一种是软件渲染机制，另一种就是硬件加速渲染机制。 
像以前的老IE时代的网页基本上都是通过CPU进行绘制的也就是采用软件渲染的机制来绘制整个页面，
要解释清楚这三种渲染机制的特性就得再介绍一个知识点，那就是光栅化。 
所谓的光栅化就是将基于数学几何数据的描述转化为基于像素点的描述。CPU和GPU都能做光栅化。
CPU做光栅化的优势是可以很方便的处理非常复杂的几何描述，例如文字的几何描述、svg-path等等这种强逻辑的路径描述等。当然缺点也很明显，例如参杂了复杂的逻辑和不可并行的特点，CPU光栅化速度会比较慢。
GPU的光栅化的优势是，GPU可以极高并发的
其实，当我们的页面从服务器请求回来时还是一些基于文本的描述，当浏览器得到html描述和css样式描述之后，浏览器就会开始解析这些描述然后变成一块一块的几何数据表述（例如描述一块内容的边框坐标点，边框的填充颜色等等基于几何数据的描述信、息。可以想象成svg的那种描述方式）。数学几何数据光栅化之后就是一张基于像素点位图了（bitmap:基于像素的描述，可以想象成jpg、png这种类型的图片）。然而目前的这一个过程还是通过CPU实现的（当然，chromuim正计划将这里适合GPU实现的步骤移交到GPU内进行处理，并且有了实质进展 感兴趣的请参考：Slimming Paint），之所以采用CPU实现这一过程的主要原因是类似于text、svg-path这种东西的路径描述比较复杂，有些时候还会有很强的逻辑在里面，比如在绘制svg-path时可能会出现某一点的位置可能会受到前N个点的影响，这种强逻辑在GPU上是不适合的，GPU擅长处理的是单纯无逻辑的点、线、三角形数据。

由于文档流的关系，后面DOM的层级默认情况下高于前面的，所以如果出现overlap的layer可以通过查看前面节点的层级来定位问题。



[raster-font]: https://www.html5rocks.com/en/tutorials/internals/antialiasing-101/?redirect_from_locale=zh#toc-text-rendering