---
title: 关于css3的transform
date: 2014-08-14
status: finished
author: jason82
---


我个人认为`CSS3`之所以能这么火，其中至少有50%的原因是因为`transform`的存在。
![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4de9e517251c170f316422f77268b375.png)

因为自从有了`transform`让我们能很方便的变换dom元素的几何形态旋转、缩放啊什么的，同时也是因为`transform`，使得`transition`和`animation`变得更加有用和高效。

`transform`提供了非常多的子变换操作，包括下面的这些：

| 空间类别 | 变换类别                                     |
| ---- | ---------------------------------------- |
| 2D   | `scale`、`rotate`、`skew`、`translate`、`matrix` |
| 3D   | `scale3d`、`rotateXYZ`、`rotate3d`、`skew`、`translate3d`、`matrix3d` |

其实`transform`功能在浏览器的底层就是通过矩阵变换来实现的，`transform`的各个子变换操作其实都相应对应着一个矩阵变换。本文并不介绍`transform`的使用，将着重介绍`transform`各个子变换的浏览器底层实现。

在介绍这些子变换之前，我们需要先了解一下`matrix`矩阵。简单的一句话概括，矩阵就是`描述空间内几何物体线性关系的参数`。我们可以利用矩阵来对空间物体进行`仿射变换`，从而能改变物体的几何形态，包括我们常见的`scale`、`rotate`、`translate`等。

> `线性变换`: 线性变换不会改变几何体的原心点位置，例如`旋转`、`缩放`、`斜切`等这些操作。

> `仿射变换`: 可以理解成包括`旋转`、`缩放`、`斜切`、`位移`等变换的组合，`位移`操作会改变几何体原本的原心点位置。

那矩阵长什么样子呢？

```jade
    | m00 m01 m02 |
M = | m10 m11 m12 |
    | m20 m21 m22 |
```

矩阵中的每个系数都发挥着不同的作用，有的可以让物体缩放，有的可以让物体位移，经过合理的组合还可以实现更复杂的效果。这个时候我们可能会有这么两个疑惑：
 1. 矩阵是如何实现对物体的仿射变换的呢，或者是transform如何改变dom元素的几何形态的？
 2. 矩阵的各个参数分别取什么值时才代表`scale`、`rotate`、`skew`、`translate`这些效果呢？


### 以矩阵乘法来使用矩阵的几何意义

我们是通过矩阵的乘法来实现几何物体的仿射变换的，例如原坐标点`(x, y, z)`通过矩阵`M`变换之后得到的坐标点`(x', y', z')`可以表示为矩阵`M`左乘`(x, y, z)`所得的结果。

```jade
矩阵乘法公式
| x' |       | x |
| y' | = M * | y |
| z' |       | z |

因为
    | m00 m01 m02 |
M = | m10 m11 m12 |
    | m20 m21 m22 |

所以
| x' |   | m00 m01 m02 |   | x |
| y' | = | m10 m11 m12 | * | y |
| z' |   | m20 m21 m22 |   | z |

变换结果
x' = m00*x + m01*y + m02*z
y' = m10*x + m11*y + m12*z
z' = m20*x + m21*y + m22*z
```

那这怎么和浏览器底层是通过矩阵改变dom元素的几何形态联系到一起呢？

其实页面在被浏览器渲染成一颗一颗的像素之前（也就是光栅化之前）都是一些的几何图形对象（GraphicsLayer），这些对象存储着该几何图形的几何体坐标点、颜色信息、图片纹理（如果这个元素有使用背景图的话）、以及矩阵信息等。当我们想缩放这个dom元素的时候，我们只需要在光栅化之前将这些几何图形对象的各个坐标点乘以一个缩放矩阵就可以实现效果啦
```jade
遍历几何图形对象的所有坐标点(x, y, z)并逐个与缩放矩阵相乘
| x' |   | 0.1  0  0 |   | x |   | 0.1*x |
| y' | = |  0  0.2 0 | * | y | = | 0.2*y |
| z' |   |  0   0  1 |   | z |   |  1*z  |

根据矩阵乘法得
x` = 0.1*x +   0*y + 0*z = 0.1*x
y` =   0*x + 0.2*y + 0*z = 0.2*y
z` =   0*x +   0*y + 1*z =   1*z
// 这样就坐标点进行了X轴缩放了0.1，Y轴缩放了0.2，当所有坐标点都经过矩阵缩放之后就得到了缩放之后的几何图形，然后浏览器在进行光栅化操作（未硬件加速的情况下）
```
> GraphicsLayer：以早期的chromium or webkit为例

### 矩阵的常见类型

矩阵可以包含非常多的功能，比如单纯含有缩放功能的叫缩放矩阵、单纯含有旋转功能的叫旋转矩阵等，然后多个功能的矩阵按序相乘又可以得到复合了这些功能的矩阵，让我们来一一揭开这些矩阵的面纱。

> 在三维空间内讨论

#### 单位矩阵

就像了解向量要先了解单位向量一样，矩阵同样也有单位矩阵。单位矩阵的作用就如同它的名字一样，不对坐标起任何变换作用。

```jade
单位矩阵
|1  0  0|
|0  1  0|
|0  0  1|

乘以待变化的坐标(x,y,z)  探索单位矩阵的几何意义 =>

|x`|   |1  0  0|   |x|
|y`| = |0  1  0| * |y|
|z`|   |0  0  1|   |z|

根据矩阵乘法得
x` = 1*x + 0*y + 0*z = x
y` = 0*x + 1*y + 0*z = y
z` = 0*x + 0*y + 1*z = z
```

所以当我们不使用transform时，你可以理解成浏览器在光栅化之前将网页上的各个几何图形对象的各个坐标点乘以了一个单位矩阵

现在我们体会到了矩阵乘法的几何意义，那么接下来我们就应该一一探索各个常见的变换所对应的变换矩阵。

### 变换矩阵推导

我们常见的变换矩阵有`scale`、`rotate`、`translate`这些场景，我们将逐个推导这些功能的具体实现。

#### 缩放`scale`

在推导缩放变换矩阵之前我们先来捋一捋缩放变换的变化过程，我们一般都是让几何体沿着坐标轴做缩放。简单来说就是针对坐标点`(x, y, z)`的各个分量分别缩放`[sx, sy, sz]`倍。

并且我们知道的是各个分量的缩放不会受到其它分量的值的影响，例如对`x`轴缩放`1.5`倍和`y`轴的数值无关。所以可以列出坐标点`(x, y, z)`的各个分量分别缩放`[sx, sy, sz]`倍的等式

```jade
x` = sx * x
y` = sy * y
z` = sz * z
```

假如这个功能通过矩阵的乘法如何体现呢？首先我们列出矩阵的乘法

```jad
|x`|   |a  d  g|   |x|
|y`| = |b  e  h| * |y|
|z`|   |c  f  i|   |z|
```

根据矩阵的乘法展开得

```jade
|x`| = a*x + d*y + g*z
|y`| = b*x + e*y + h*z
|z`| = c*x + f*y + i*z
```

因为各个轴的缩放不会受其他坐标分量的数值影响所以很容易知道

```jade
d = g = b = h = c = f = 0

带入可得 =>
x` = a * x
y` = e * y
z` = i * z
```

所以对坐标点`(x, y, z)`的各个分量分别缩放`[sx, sy, sz]`倍的缩放矩阵应该是

```jade
|a  d  g|
|b  e  h|
|c  f  i|

根据已知条件 =>

|sx  0   0 |
|0   sy  0 |
|0   0   sz|
```

当我们使用`transform: scale3d(1, 2, 1);`来变化dom元素时，其实浏览器只是在光栅化之前将网页上的各个几何图形对象的各个坐标点乘以了一个缩放矩阵

```jade
|1   0   0 |
|0   2   0 |
|0   0   1 |
```

> 缩放矩阵还是非常简单的，里面的已知量比较多，几乎代入就能推导出来。

#### 旋转`rotate`

旋转矩阵的推导对比缩放矩阵稍微比较麻烦，但是都是一些基本的数学知识。这里我们将用传统的数学方法来推导出旋转矩阵的各个系数。

> ⚠️注意：一般空间中的旋转有很多种，常用的有`欧拉角`和`四元数`的形式，这里我们先讨论`欧拉角`的形式

##### 欧拉角

欧拉角听起来好像很高大上，其实它就是我们最常见的描述空间内物体旋转的方式。比如物体`A`围绕`x`轴先旋转30度，再围绕`y`轴旋转45度，再围绕`z`轴旋转30度，这种就是一欧拉角的形式描述的旋转。其实也就是我们品尝使用`transform`中的`rotateX`、`rotateY`、`rotateZ`系列的操作。

那么欧拉角对应的旋转矩阵描述长什么样子的呢？下面我们就按照常规的数学方式来来推导出欧拉角的旋转矩阵。

首先我们来思考一下旋转的实际过程。

就以绕右手笛卡尔坐标系的`Z`轴为例。我们知道物体绕某一轴旋转，那么该物体的所有坐标点在该轴上的分量是保持不变的，所以这样一来绕`Z`轴旋转我们就只需要考虑坐标点的`x`和`y`分量了。[查看示例](https://jasonchen1982.github.io/web-ppt/cf2-sharing/#/23)

![rotate](https://jasonchen1982.github.io/blog/source/matrix/rotate.png)

从上图可以看到，坐标点`(x, y)`经过旋转`β`角度后到达`(x', y')`点，以此我们可以得到一些已知量。

```jade
r = √(x^2+y^2)

// 单位圆得到等式
x` = cos(β+α) * r
y` = sin(β+α) * r

// 和差化积公式
sin(β+α) = sin(β)cos(α) + cos(β)sin(α)
cos(β+α) = cos(β)cos(α) - sin(β)sin(α)

cos(α) = x/r
sin(α) = y/r

// 愉快的代入
x` = (cos(β)x/r - sin(β)y/r) * r = cos(β)x - sin(β)y
y` = (sin(β)x/r + cos(β)y/r) * r = sin(β)x + cos(β)y

所以猜想旋转矩阵 =>

|cos(β) -sin(β)|
|sin(β)  cos(β)|

验证下 =>

|x`|   |cos(β) -sin(β)|   |x|
|y`| = |sin(β)  cos(β)| * |y|

x` = cos(β)x - sin(β)y
y` = sin(β)x + cos(β)y
```

这里推广的是绕`Z`轴旋转的二维旋转矩阵，同时可以快速推广到绕`Z`轴旋转的三维旋转矩阵。

因为绕`Z`轴旋转，`Z`轴的分量是不变的，所以矩阵影响`Z`的系数只要维持`单位矩阵`的系数就可以了，所以可以得到三维的绕`Z`轴旋转的旋转矩阵。

```jade
|cos(β) -sin(β)  0|
|sin(β)  cos(β)  0|
|  0       0     1|
```

同理也可以推导出绕其他轴旋转的矩阵，例如：

###### 绕`X`轴旋转

```jade
|1   0     0  |
|0  cosβ  sinβ|
|0 -sinβ  cosβ|
```

###### 绕`Y`轴旋转

```jade
|cosβ   0   sinβ|
|  0    1    0  |
|-sinβ  0   cosβ|
```

矩阵中系数的符号取决于你的旋转正方向的选择。

当我们使用`transform: rotateZ(30deg);`来旋转dom元素时，其实浏览器只是在光栅化之前将网页上的各个几何图形对象的各个坐标点乘以了一个旋转矩阵。来达到旋转的目的

```jade
|cos(β) -sin(β)  0|
|sin(β)  cos(β)  0|
|  0       0     1|
```

#### 位移`translate`

`translate`相比于前面所讲到的`scale`、`rotate`有点不一样，你会发现前面的那些线性变换操作不会改变几何体原本的`(0, 0, 0)`点位置，但是`translate`则会改变这个特性，这种特性可以称为仿射变换。

> 实际上`scale`、`rotate`、`skew`等这些属于线性变换，而`translate`不属于线性变换。但是他们可以统称为`仿射变换`

我们尴尬的发现目前的3*3的矩阵的每一行正好被三维空间的线性变换，没办法承载`translate`这种非线性变换。

为了让矩阵能够同时解决`线性变换`和`translate`变换，我们得多引入一个维度的系数。

这时我们要引入另一个概念，那就是`齐次坐标`。将原本的`(x,y,z)`变成`(x,y,z,1)`。

相应的矩阵也多加一个维度：

```jade
|a  d  g  j|
|b  e  h  k|
|c  f  i  l|
|0  0  0  1|
```

`transform: translate3d(10px, 20px, -5px)`的实际作用就是让坐标在原来的基础之上再加相应的偏移值.

根据矩阵的乘法我们发现。

```jade
将矩阵与齐次坐标相乘
| x' |   | a  d  g  j |   | x |
| y' | = | b  e  h  k | * | y |
| z' |   | c  f  i  l |   | z |
| 1  |   | 0  0  0  1 |   | 1 |

变换结果
x' = a*x + d*y + g*z +j*1;
y' = b*x + e*y + h*z +k*1;
z' = c*x + f*y + i*z +l*1;
1' = 0*x + 0*y + 0*z +1*1;

// 系数i、j、k的作用似乎刚好符合我们的要求，假设原本的3*3矩阵为单位矩阵
|1  0  0  j|
|0  1  0  k|
|0  0  1  l|
|0  0  0  1|

得到
x' = 1*x + 0*y + 0*z +j*1 = x + j;
y' = 0*x + 1*y + 0*z +k*1 = y + k;
z' = 0*x + 0*y + 1*z +l*1 = z + l;
1' = 0*x + 0*y + 0*z +1*1 = 1;
```

当我们使用`transform: translate3d(10px, 20px, -5px);`来偏移dom元素时，其实浏览器只是在光栅化之前将网页上的各个几何图形对象的各个坐标点乘以了一个偏移矩阵。
|1  0  0  10|
|0  1  0  20|
|0  0  1  -5|
|0  0  0   1|

#### 小结
我们发现三维空间内，只要把`3*3`矩阵扩展到`4*4`的矩阵就可以让矩阵同时描述线性变换和translate变换了，其实同理在二维情况下也是这样。

因此在`css3`中`transform`的二维`matrix`接收6个参数，三维`matrix3d`接收12个参数，他们的含义分别是

```jade
|a  c  e|
|b  d  f|    =>    matrix(a, b, c, d, e, f)
|0  0  1|
```

和三维的

```jade
|a  e  i  m|
|b  f  j  n|    =>    matrix3d(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
|c  g  k  o|
|d  h  l  p|
```

#### `custom matrix`自定义变换

我们除了利用浏览器直接提供给我们的变换效果。

例如还可以依赖`matrix`接口实现自定义的几何变换。

下面我将以二维情况下的镜像变换为例子，利用`matrix`实现镜像变换。需求如下

![reflection](https://jasonchen1982.github.io/web-ppt/light-talk-1/imgs/axis.jpg)

让物体以直线`y = k * x`为对称轴进行镜像对称变换，通过示意图我们可以得到等式如下：

```jade
设 k 为对称轴的斜率
(y - y`) / (x - x`) = -1/k    ＝》    ky - ky` = x` - x      等式 1
```

既然直线`y = k * x`是对称轴，那么点`point`和`point'`的中心点`center`一定在`y = k * x`上

```jade
center = ( (x+x`)/2, (y+y`)/2 )
所以
k * (x+x`)/2 = (y+y`)/2       ＝》    y+y` = kx + kx`        等式 2
```

分别对`等式1`和`等式2`进行移位变形可以得到

```jade
x` = ky - ky` + x
y` = kx + kx` - y
```

互相替换代人

```jade
x` = ky - k(kx + kx` - y) + x   ＝》   x` = ky - k^2x - k^2x` + ky + x
y` = kx + k(ky - ky` + x) - y   ＝》   y` = kx + k^2y - k^2y` + kx - y
等式变形
(1+k^2)x` = 2ky + (1-k^2)x      ＝》   x` = (1-k^2)/(1+k^2) * x +    (2k)/(1+k^2) * y
(1+k^2)y` = 2kx + (k^2-1)y      ＝》   y` =    (2k)/(1+k^2) * x - (1-k^2)/(1+k^2) * y
```

推到这个等式大家是不是就挺熟悉了？等于二维的镜像变换的矩阵就是：

```jade
| (1-k^2)/(1+k^2)    2k/(1+k^2)    |
|    2k/(1+k^2)   -(1-k^2)/(1+k^2) |


如果需要使用到matrix(a,b,c,d,e,f)就得补位成这样

| (1-k^2)/(1+k^2)    2k/(1+k^2)     0|
|    2k/(1+k^2)   -(1-k^2)/(1+k^2)  0|
|        0               0          1|

```

> k = tan(θ)，θ为直线与x轴的夹角
