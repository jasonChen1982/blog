---
title: 关于css3的transform
date: 2014-08-14
status: finished
author: jason82
---


我个人认为`CSS3`之所以能这么火，其中有60%的原因是因为`transform`的存在。`transform`让我们能很方便的变换元素的几何形态，同时也是因为`transform`，使得`transition`和`animation`变得更加有用。

`transform`提供了非常多的子变换操作，包括下面的这些：

| 空间类别 | 变换类别                                     |
| ---- | ---------------------------------------- |
| 2D   | `scale`、`rotate`、`skew`、`translate`、`matrix` |
| 3D   | `scale3d`、`rotate3d`、`skew`、`translate3d`、`matrix3d` |

在浏览器的底层`transform`功能就是通过矩阵变换来实现的，`transform`的各个子变换操作其实都相应对应着一个矩阵变换。本文并不介绍`transform`的使用，将着重介绍`transform`各个子变换的浏览器底层实现。

在我们讲这些变换之前，我们需要先了解一下`matrix`矩阵。简单的一句话概括，矩阵就是描述空间内几何物体线性关系的参数。我们可以利用矩阵来对空间物体进行仿射变换，从而能过线性的改变物体的几何形态，包括我们常见的`scale`、`rotate`、`translate`等。

那矩阵长什么样子呢？

```jade
| m00 m01 m02 |
| m10 m11 m12 |
| m20 m21 m22 |
```

矩阵中的每个系数都发挥着不同的作用，有的可以让物体缩放，有的可以让物体位移，经过合理的组合还可以实现旋转的效果。那这样我们就遇到了两个问题：
 1. 矩阵是如何实现对物体的线性变换的呢？
 2. 矩阵的各个参数分别取什么值时才代表`scale`、`rotate`、`skew`、`translate`这些效果呢？


### 矩阵乘法

我们是通过矩阵的乘法来实现几何物体的变换的，例如原坐标点`(x, y, z)`通过矩阵`M`变换之后得到的坐标点`(x', y', z')`可以表示为矩阵`M`左乘`(x, y, z)`所得的结果。

```jade
矩阵乘法公式
| x' |   | m00 m01 m02 |   | x |
| y' | = | m10 m11 m12 | * | y |
| w' |   | m20 m21 m22 |   | w |

变换结果
x' = m00*x + m01*y + m02*w
y' = m10*x + m11*y + m12*w
w' = m20*x + m21*y + m22*w
```

#### 单位矩阵

就像我们当初学向量要先学单位向量一样，矩阵同样也有单位矩阵。单位矩阵的作用就如同它的名字一样，不对坐标起任何变换作用。

```jade
单位矩阵
|1  0  0|
|0  1  0|
|0  0  1|

乘以待变化的坐标(x,y,w)  探索单位矩阵的几何意义 =>

|x`|   |1  0  0|   |x|
|y`| = |0  1  0| * |y|
|w`|   |0  0  1|   |w|

根据矩阵乘法得
x` = 1*x + 0*y + 0*w = x
y` = 0*x + 1*y + 0*w = y
w` = 0*x + 0*y + 1*w = w
```

现在我们体会到了矩阵乘法的几何意义，那么接下来我们就应该一一探索各个常见的变换所对应的变换矩阵。

### 变换矩阵推导

我们常见的变换矩阵有`scale`、`rotate`、`translate`这些场景，我们将逐个推导这些功能的具体实现。

#### 缩放`scale`

在推导缩放变换矩阵之前我们先来捋一捋缩放变换的变化过程，我们一般都是让几何体沿着坐标轴做缩放。简单来说就是针对坐标点`(x, y, z)`的各个分量分别缩放`[sx, sy, sz]`倍。

并且我们清楚各个分量的缩放不会受到其它分量的值的影响，例如对`x`轴缩放`1.5`倍和`y`轴的数值无关。所以可以列出坐标点`(x, y, z)`的各个分量分别缩放`[sx, sy, sz]`倍的等式

```jade
x` = sx * x
y` = sy * y
z` = sz * z
```

假如这个功能通过矩阵的乘法如何体现呢？首先我们列出矩阵的乘法

```jad
|x`|   |a  d  g|   |x|
|y`| = |b  e  h| * |y|
|z`|   |c  f  i|   |z|
```

根据矩阵的乘法展开得

```jade
|x`| = a*x + d*y + g*z
|y`| = b*x + e*y + h*z
|z`| = c*x + f*y + i*z
```

因为各个轴的缩放不会受其他坐标分量的数值影响所以很容易知道

```jade
d = g = b = h = c = f = 0

带入可得 =>
x` = a * x
y` = e * y
z` = i * z
```

所以对坐标点`(x, y, z)`的各个分量分别缩放`[sx, sy, sz]`倍的缩放矩阵应该是

```jade
|a  d  g|
|b  e  h|
|c  f  i|

根据已知条件 =>

|sx  0   0 |
|0   sy  0 |
|0   0   sz|
```

缩放矩阵还是非常简单的，里面的已知量比较多，几乎代入就能推导出来。

#### 旋转`rotate`

旋转矩阵的推导对比缩放矩阵稍微比较麻烦，但是都是一些基本的数学知识。这里我们将用传统的数学方法来推导出旋转矩阵的各个系数。

> ⚠️注意：一般空间中的旋转有很多种，常用的有`欧拉角`和`四元数`的形式，这里我们先讨论`欧拉角`的形式

##### 欧拉角

欧拉角听起来好像很高大上，其实它就是我们最常见的描述空间内物体旋转的方式。比如物体`A`围绕`x`轴先旋转30度，再围绕`y`轴旋转45度，再围绕`z`轴旋转30度，这种就是一欧拉角的形式描述的旋转。其实也就是我们品尝使用`transform`中的`rotateX`、`rotateY`、`rotateZ`系列的操作。

那么欧拉角对应的旋转矩阵描述长什么样子的呢？下面我们就按照常规的数学方式来来推导出欧拉角的旋转矩阵。

首先我们来思考一下旋转的实际过程。

就以绕右手笛卡尔坐标系的`Z`轴为例。我们知道物体绕某一轴旋转，那么该物体的所有坐标点在该轴上的分量是保持不变的，所以这样一来绕`Z`轴旋转我们就只需要考虑坐标点的`x`和`y`分量了。[查看示例](https://jasonchen1982.github.io/web-ppt/cf2-sharing/#/23)

![rotate](https://jasonchen1982.github.io/blog/source/matrix/rotate.png)

从上图可以看到，坐标点`(x, y)`经过旋转`β`角度后到达`(x', y')`点，以此我们可以得到一些已知量。

```jade
r = √(x^2+y^2)

// 单位圆得到等式
x` = cos(β+α) * r
y` = sin(β+α) * r

// 和差化积公式
sin(β+α) = sin(β)cos(α) + cos(β)sin(α)
cos(β+α) = cos(β)cos(α) - sin(β)sin(α)

cos(α) = x/r
sin(α) = y/r

// 愉快的代入
x` = (cos(β)x/r - sin(β)y/r) * r = cos(β)x - sin(β)y
y` = (sin(β)x/r + cos(β)y/r) * r = sin(β)x + cos(β)y

所以猜想旋转矩阵 =>

|cos(β) -sin(β)|
|sin(β)  cos(β)|

验证下 =>

|x`|   |cos(β) -sin(β)|   |x|
|y`| = |sin(β)  cos(β)| * |y|

x` = cos(β)x - sin(β)y
y` = sin(β)x + cos(β)y
```

这里推广的是绕`Z`轴旋转的二维旋转矩阵，同时可以快速推广到绕`Z`轴旋转的三维旋转矩阵。

因为绕`Z`轴旋转，`Z`轴的分量是不变的，所以矩阵影响`Z`的系数只要维持`单位矩阵`的系数就可以了，所以可以得到三维的绕`Z`轴旋转的旋转矩阵。

```jade
|cos(β) -sin(β)  0|
|sin(β)  cos(β)  0|
|  0       0     1|
```

同理也可以推导出绕其他轴旋转的矩阵，例如：

###### 绕`X`轴旋转

```jade
|1   0     0  |
|0  cosβ  sinβ|
|0 -sinβ  cosβ|
```

###### 绕`Y`轴旋转

```jade
|cosβ   0   sinβ|
|  0    1    0  |
|-sinβ  0   cosβ|
```

矩阵中系数的符号取决于你的旋转正方向的选择。

##### 四元数

TODO:

#### 位移`translate`
































