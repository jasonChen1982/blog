---
title: 关于css3的transform
date: 2014-08-14
status: finished
author: jason82
---


我个人认为`CSS3`之所以能这么火，其中有60%的原因是因为`transform`的存在。`transform`让我们能很方便的变换元素的几何形态，同时也是因为`transform`，使得`transition`和`animation`变得更加有用。

`transform`提供了非常多的子变换操作，包括下面的这些：

| 空间类别 | 变换类别                                     |
| ---- | ---------------------------------------- |
| 2D   | `scale`、`rotate`、`skew`、`translate`、`matrix` |
| 3D   | `scale3d`、`rotate3d`、`skew`、`translate3d`、`matrix3d` |

在浏览器的底层`transform`功能就是通过矩阵变换来实现的，`transform`的各个子变换操作其实都相应对应着一个矩阵变换。本文并不介绍`transform`的使用，将着重介绍`transform`各个子变换的浏览器底层实现。

在我们讲这些变换之前，我们需要先了解一下`matrix`矩阵。简单的一句话概括，矩阵就是描述空间内几何物体线性关系的参数。我们可以利用矩阵来对空间物体进行仿射变换，从而能过线性的改变物体的几何形态，包括我们常见的`scale`、`rotate`、`translate`等。

那矩阵长什么样子呢？

```jade
| m00 m01 m02 |
| m10 m11 m12 |
| m20 m21 m22 |
```

矩阵中的每个系数都发挥着不同的作用，有的可以让物体缩放，有的可以让物体位移，经过合理的组合还可以实现旋转的效果。那这样我们就遇到了两个问题：
 1. 矩阵是如何实现对物体的线性变换的呢？
 2. 矩阵的各个参数分别取什么值时才代表`scale`、`rotate`、`skew`、`translate`这些效果呢？


### 矩阵乘法

我们是通过矩阵的乘法来实现几何物体的变换的，例如原坐标点`(x, y, z)`通过矩阵`M`变换之后得到的坐标点`(x', y', z')`可以表示为矩阵`M`左乘`(x, y, z)`所得的结果。

```jade
矩阵乘法公式
| x' |   | m00 m01 m02 |   | x |
| y' | = | m10 m11 m12 | * | y |
| w' |   | m20 m21 m22 |   | w |

变换结果
x' = m00*x + m01*y + m02*w
y' = m10*x + m11*y + m12*w
w' = m20*x + m21*y + m22*w
```

#### 单位矩阵

就像我们当初学向量要先学单位向量一样，矩阵同样也有单位矩阵。单位矩阵的作用就如同它的名字一样，不对坐标起任何变换作用。

```jade
单位矩阵
|1  0  0|
|0  1  0|
|0  0  1|

乘以待变化的坐标(x,y,w)  探索单位矩阵的几何意义 =>

|x`|   |1  0  0|   |x|
|y`| = |0  1  0| * |y|
|w`|   |0  0  1|   |w|

根据矩阵乘法得
x` = 1*x + 0*y + 0*w = x
y` = 0*x + 1*y + 0*w = y
w` = 0*x + 0*y + 1*w = w
```

现在我们体会到了矩阵乘法的几何意义，那么接下来我们就应该一一探索各个常见的变换所对应的变换矩阵。

### 变换矩阵推导

我们常见的变换矩阵有`scale`、`rotate`、`translate`这些场景，我们将逐个推导这些功能的具体实现。

#### 缩放`scale`

在推导缩放变换矩阵之前我们先来捋一捋缩放变换的变化过程，我们一般都是让几何体沿着坐标轴做缩放。简单来说就是针对坐标点`(x, y, z)`的各个分量分别缩放`[sx, sy, sz]`倍。

并且我们清楚各个分量的缩放不会受到其它分量的值的影响，例如对`x`轴缩放`1.5`倍和`y`轴的数值无关。所以可以列出坐标点`(x, y, z)`的各个分量分别缩放`[sx, sy, sz]`倍的等式

```jade
x` = sx * x
y` = sy * y
z` = sz * z
```

假如这个功能通过矩阵的乘法如何体现呢？首先我们列出矩阵的乘法

```jad
|x`|   |a  d  g|   |x|
|y`| = |b  e  h| * |y|
|z`|   |c  f  i|   |z|
```

根据矩阵的乘法展开得

```jade
|x`| = a*x + d*y + g*z
|y`| = b*x + e*y + h*z
|z`| = c*x + f*y + i*z
```

因为各个轴的缩放不会受其他坐标分量的数值影响所以很容易知道

```jade
d = g = b = h = c = f = 0

带入可得 =>
x` = a * x
y` = e * y
z` = i * z
```

所以对坐标点`(x, y, z)`的各个分量分别缩放`[sx, sy, sz]`倍的缩放矩阵应该是

```jade
|a  d  g|
|b  e  h|
|c  f  i|

根据已知条件 =>

|sx  0   0 |
|0   sy  0 |
|0   0   sz|
```

缩放矩阵还是非常简单的，里面的已知量比较多，几乎代入就能推导出来。

#### 旋转`rotate`

旋转矩阵的推导对比缩放矩阵稍微比较麻烦，但是都是一些基本的数学知识。这里我们将用传统的数学方法来推导出旋转矩阵的各个系数。

> ⚠️注意：一般空间中的旋转有很多种，常用的有`欧拉角`和`四元数`的形式，这里我们先讨论`欧拉角`的形式

##### 欧拉角

欧拉角听起来好像很高大上，其实它就是我们最常见的描述空间内物体旋转的方式。比如物体`A`围绕`x`轴先旋转30度，再围绕`y`轴旋转45度，再围绕`z`轴旋转30度，这种就是一欧拉角的形式描述的旋转。其实也就是我们品尝使用`transform`中的`rotateX`、`rotateY`、`rotateZ`系列的操作。

那么欧拉角对应的旋转矩阵描述长什么样子的呢？下面我们就按照常规的数学方式来来推导出欧拉角的旋转矩阵。

首先我们来思考一下旋转的实际过程。

就以绕右手笛卡尔坐标系的`Z`轴为例。我们知道物体绕某一轴旋转，那么该物体的所有坐标点在该轴上的分量是保持不变的，所以这样一来绕`Z`轴旋转我们就只需要考虑坐标点的`x`和`y`分量了。[查看示例](https://jasonchen1982.github.io/web-ppt/cf2-sharing/#/23)

![rotate](https://jasonchen1982.github.io/blog/source/matrix/rotate.png)

从上图可以看到，坐标点`(x, y)`经过旋转`β`角度后到达`(x', y')`点，以此我们可以得到一些已知量。

```jade
r = √(x^2+y^2)

// 单位圆得到等式
x` = cos(β+α) * r
y` = sin(β+α) * r

// 和差化积公式
sin(β+α) = sin(β)cos(α) + cos(β)sin(α)
cos(β+α) = cos(β)cos(α) - sin(β)sin(α)

cos(α) = x/r
sin(α) = y/r

// 愉快的代入
x` = (cos(β)x/r - sin(β)y/r) * r = cos(β)x - sin(β)y
y` = (sin(β)x/r + cos(β)y/r) * r = sin(β)x + cos(β)y

所以猜想旋转矩阵 =>

|cos(β) -sin(β)|
|sin(β)  cos(β)|

验证下 =>

|x`|   |cos(β) -sin(β)|   |x|
|y`| = |sin(β)  cos(β)| * |y|

x` = cos(β)x - sin(β)y
y` = sin(β)x + cos(β)y
```

这里推广的是绕`Z`轴旋转的二维旋转矩阵，同时可以快速推广到绕`Z`轴旋转的三维旋转矩阵。

因为绕`Z`轴旋转，`Z`轴的分量是不变的，所以矩阵影响`Z`的系数只要维持`单位矩阵`的系数就可以了，所以可以得到三维的绕`Z`轴旋转的旋转矩阵。

```jade
|cos(β) -sin(β)  0|
|sin(β)  cos(β)  0|
|  0       0     1|
```

同理也可以推导出绕其他轴旋转的矩阵，例如：

###### 绕`X`轴旋转

```jade
|1   0     0  |
|0  cosβ  sinβ|
|0 -sinβ  cosβ|
```

###### 绕`Y`轴旋转

```jade
|cosβ   0   sinβ|
|  0    1    0  |
|-sinβ  0   cosβ|
```

矩阵中系数的符号取决于你的旋转正方向的选择。

##### 四元数

TODO:

#### 位移`translate`

相比于前面所讲到的`scale`、`rotate`，`translate`有点不一样，你会发现前面的变换操作不会改变几何体的`(0, 0, 0)`点位置，但是`translate`则会改变这个特性，所以我们需要扩展变换矩阵来支持这一变换操作。

> 实际上`scale`、`rotate`、`skew`等这些属于线性变换，而`translate`不属于线性变换。但是他们可以统称为`仿射变换`

这时我们要引入另一个概念，那就是`齐次坐标`。为了让矩阵既能够解决`线性变换`又能够解决像`translate`这样比较特殊的变换，我们多引入一些系数。

根据矩阵的乘法我们发现

```jade
矩阵乘法公式
| x' |   | 1 0 e |   | x |
| y' | = | 0 1 f | * | y |
| 1  |   | 0 0 1 |   | 1 |

变换结果
x' = x + e
y' = y + f
1  = 1
```

我们发现二维的时候，只要把矩阵扩展到`3*3`就可以包含位移变换了，同理三维的时候需要`4*4`的矩阵。

因此在`css3`中`transform`的`matrix`接收6个参数，`matrix3d`接收12个参数，他们的含义分别是

```jade
|a  c  e|
|b  d  f|    =>    matrix(a, b, c, d, e, f)
|0  0  1|
```

和三维的

```jade
|a  e  i  m|
|b  f  j  n|    =>    matrix3d(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
|c  g  k  o|
|d  h  l  p|
```

#### `custom matrix`自定义变换

我们除了利用浏览器直接提供给我们的变换效果，我们还可以依赖`matrix`接口实现自定义的几何变换。

下面我将以镜像变换为例子，利用`matrix`实现镜像变换。需求如下

![reflection](https://jasonchen1982.github.io/web-ppt/light-talk-1/imgs/axis.jpg)

让物体以直线`y = k * x`为对称轴进行镜像对称变换，通过示意图我们可以得到等式如下：

```jade
设 k 为对称轴的斜率
(y - y`) / (x - x`) = -1/k    ＝》    ky - ky` = x` - x      等式 1
```

既然直线`y = k * x`是对称轴，那么点`point`和`point'`的中心点`center`一定在`y = k * x`上

```jade
center = ( (x+x`)/2, (y+y`)/2 )
所以
k * (x+x`)/2 = (y+y`)/2       ＝》    y+y` = kx + kx`        等式 2
```

分别对`等式1`和`等式2`进行移位变形可以得到

```jade
x` = ky - ky` + x
y` = kx + kx` - y
```

互相替换代人

```jade
x` = ky - k(kx + kx` - y) + x   ＝》   x` = ky - k^2x - k^2x` + ky + x
y` = kx + k(ky - ky` + x) - y   ＝》   y` = kx + k^2y - k^2y` + kx - y
等式变形
(1+k^2)x` = 2ky + (1-k^2)x      ＝》   x` = (1-k^2)/(1+k^2) * x +    (2k)/(1+k^2) * y
(1+k^2)y` = 2kx + (k^2-1)y      ＝》   y` =    (2k)/(1+k^2) * x - (1-k^2)/(1+k^2) * y
```

推到这个等式大家是不是就挺熟悉了？等于二维的镜像变换的矩阵就是：

```jade
| (1-k^2)/(1+k^2)    2k/(1+k^2)    |
|    2k/(1+k^2)   -(1-k^2)/(1+k^2) |


如果需要使用到matrix(a,b,c,d,e,f)就得补位成这样

| (1-k^2)/(1+k^2)    2k/(1+k^2)     0|
|    2k/(1+k^2)   -(1-k^2)/(1+k^2)  0|
|        0               0          1|

```

> k = tan(θ)，θ为直线与x轴的夹角